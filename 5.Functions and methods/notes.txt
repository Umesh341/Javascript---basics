==============================================
         function
==============================================

> function is a block of code designed to perform a particular task. It is executed when "called" or "invoked".

function ko parameter --> are like local vaiable in the function which has the block scope.

________________________________________________________
  // function to check if a number is prime
        function isPrime(num) {
            if (num <= 1) return false;
            for (let i = 2; i <= Math.sqrt(num); i++) {
                if (num % i === 0) return false;
            }
            return true;
        }
        console.log("Is 7 prime? ", isPrime(7)); // true

        // arrow function
        const multiplication=(a,b)=>{
            return a*b;
        }
        console.log("Multiplication of 4 and 5: ", multiplication(4, 5)); // 20
        const sum = (a, b) => a + b;
        console.log("Sum of 10 and 15: ", sum(10, 15    )); // 25 
________________________________________________________

arrow function --> is a more concise syntax for writing functions in JavaScript. They do not have their own 'this' context.
> Note: Arrow functions are not suitable for all situations, especially when dealing with methods in objects or when 'this' context is important.
________________________________________________________
let arrowf =()=>{
    console.log("This is an arrow function");
}
arrowf = 1232;
console.log(arrowf); // 1232
________________________________________________________


Counting Vowel
___________________________________________________________________
 function countVowel(str){
            let count =0;
            for(let i=0; i< str.length; i++){
                if(str[i] =='a' || 
                   str[i] == 'e'||
                    str[i] == 'i'  || 
                    str[i] == 'o' ||
                     str[i] == 'u'
                ){
                      count++;
                }
            }
            console.log("no of vowel : ", count); // only lowercase vowels
        }
__________________________________________________________________


==========================================================================
callback function and Higher order function
==========================================================================

in JS function can be send as an argument to another function.
call back function --> function passed as an argument to another function.

also function can return another function
Higher order function --> function that takes another function as an argument or returns a function as a result.    

_________________________________________________________
function greet(name, callback) {
    return "Hello " + name + ", " + callback();
}   
function getTime() {
    const date = new Date();
    return "Current time is: " + date.toLocaleTimeString();
}   
console.log(greet("Alice", getTime));
_________________________________________________________   

==========================================================================
For each loop
==========================================================================
> forEach() method executes a provided function once for each array element.
> for each loop is only used with arrays.
> forEach is an example of higher order function as it takes a callback function as an argument.
__________________________________________________________________________
const numbers = [1, 2, 3, 4, 5];
numbers.forEach((number) => {
    console.log(number * 2); // 2, 4, 6, 8, 10
});


        const numbers = [1, 2, 3, 4, 5];
        numbers.forEach((val, index, arr) => {
           console.log(val, index, arr);
        });
________________________________________________________




==============================================================================
     some important points about function
==============================================================================

=========================================================================================
1. function declaration hoisting --> function declarations are hoisted to the top of their containing scope, meaning they can be called before they are defined in the code.
=========================================================================================
________________________________________________________
// function declaration hoisting example
console.log(add(2, 3)); // 5
function add(a, b) {
    return a + b;
}
________________________________________________________

=========================================================================================
2. function expression hoisting --> function expressions are not hoisted, so they cannot be called before they are defined.
========================================================================================
________________________________________________________
// function expression hoisting example
try {
    console.log(subtract(5, 2)); // Error: subtract is not defined
} catch (e) {
    console.log(e.message);
}
const subtract = function(a, b) {
    return a - b;
};
_________________________________________________________
> Function declarations are hoisted, while function expressions are not.
_________________________________________________________   
try {
    console.log(subtract(5, 2)); // 3
} catch (e) {
    console.log(e.message);
}
function subtract(a, b) {
    return a - b;
};
________________________________________________________

=========================================================================================
3. 'this' context in functions --> In regular functions, 'this' refers to the object that called the function. In arrow functions, 'this' is lexically bound to the surrounding scope.=========================================================================================
________________________________________________________
> Arrow functions do not have their own 'this' context; they inherit 'this' from the surrounding lexical scope.
lexical scope --> the context in which a function is defined, not where it is called.
________________________________________________________
const obj = {
    value: 42,
    regularFunction: function() {
        console.log(this.value); // 42
    },
    arrowFunction: () => {
        console.log(this.value); // undefined, 'this' does not refer to obj
    }
};
obj.regularFunction();
obj.arrowFunction();
________________________________________________________

========================================================================================
> Functions can have default parameters, which are used if no argument is provided for that parameter when the function is called.
========================================================================================
________________________________________________________
// default parameter example
function greet(name = "Guest") {
    return "Hello, " + name + "!";
}   
console.log(greet()); // "Hello, Guest!"
console.log(greet("Alice")); // "Hello, Alice!"
________________________________________________________

========================================================================================
> Functions can be nested within other functions, allowing for encapsulation and creating closures.
========================================================================================
________________________________________________________
function outerFunction() {
    function innerFunction() {
        return "Hello from inner function!";
    }   
    return innerFunction();
}   
console.log(outerFunction()); // "Hello from inner function!"  
________________________________________________________ 





==============================================================================
                        Some array methods
==============================================================================

==========================================================================
1. map() --> creates a new array populated with the results of calling a provided function on every element in the calling array. 
 // similar to for each loop
==========================================================================
foreach is generally used to perform side effects like logging or updating external variables, 
whereas map is used to transform data and create new arrays.
__________________________________________________________________
const numbers = [1, 2, 3, 4, 5];
const tripled = numbers.map((number) => number * 3);
console.log(tripled); // [3, 6, 9, 12, 15]
const double = numbers.map(function(number, index, array){
    return number * 2;
});

const arr = [1, 2, 3, 4, 5];

const newCopy = arr.map((val) => val);
console.log(newCopy); // [1, 2, 3, 4, 5]
__________________________________________________________________


==========================================================================
2. filter() --> creates a new array with all elements that pass the test implemented by the
provided function.
==========================================================================
___________________________________________________________
const numbers = [1, 2, 3, 4, 5, 6];
const evenNumbers = numbers.filter((number) => number % 2 === 0);
console.log(evenNumbers); // [2, 4, 6]
___________________________________________________________

==========================================================================
3. reduce() --> executes a reducer function (that you provide) on each element of the array, resulting in a single output value.
==========================================================================
___________________________________________________________
 reduce(callback(accumulator, currentValue, index, array), initialValue)
___________________________________________________________
const numbers = [1, 2, 6, 4, 5];
const sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 3);
// initial value is 3
// accumulator starts with 3
// iterations: (3+1)=4, (4+2)=6, (6+6)=12, (12+4)=16, (16+5)=21
console.log(sum); // 21
___________________________________________________________
// find sum of array elements
const arr = [10, 20, 30, 40];
const total = arr.reduce((acc, val) => acc + val, 0);
// initial value is 0
// accumulator starts with 0
// iterations: (0+10)=10, (10+20)=30, (30+30)=60, (60+40)=100
console.log(total); // 100
___________________________________________________________

// maximum element in array using reduce
const arr = [5, 12, 8, 20, 3];
const max = arr.reduce((acc, val) => (val > acc ? val : acc), arr[0]);
console.log(max); // 20
___________________________________________________________

==========================================================================
4. find() --> returns the value of the first element in the provided array that satisfies the provided testing function. If no values satisfy the testing function, undefined is returned.
==========================================================================
___________________________________________________________
const numbers = [1, 3, 7, 8, 10];
const firstEven = numbers.find((number) => number % 2 === 0);
console.log(firstEven); // 8
___________________________________________________________

==========================================================================
5. findIndex() --> returns the index of the first element in the array that satisfies the provided testing function. If no elements satisfy the testing function, -1 is returned.
==========================================================================

___________________________________________________________
const numbers = [1, 3, 7, 8, 10];
const firstEvenIndex = numbers.findIndex((number) => number % 2 === 0);
console.log(firstEvenIndex); // 3
___________________________________________________________